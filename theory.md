# Теоретическая часть

## Условие задачи
Реализовать алгоритм сжатия данных LZW для различных типов данных.

## Формальная постановка задачи
Реализовать алгоритм сжатия данных LZW, работающий с любыми данными. На вход поступают два файла: входной и выходной. Алгоритм должен реализовывать функцию сжатия и распаковки.

## Алгоритм LZW
Таблица(словарь) - контейнер, обеспечивающий взаимнооднозначные определенные пары: последовательности бит и фраз.

### Алгоритм сжатия
Алгоритм LZW-сжатия посимвольно считывает входные данные и ищет максимально длинную строку, встречающуюся в словаре. Если встречается строка, которой нет в словаре, происходит ее добавление и дальнейший поиск осуществляется с последнего символа этой строки. Каждый раз, когда новая строка добавляется в таблицу строк, генерируется новый код. LZW постоянно проверяет, является ли строка уже известной, и, если так, выводит существующий код без генерации нового.
Процедуру LZW-сжатия можно представить как:

- СТРОКА = очередной символ из входного потока
- WHILE входной поток не пуст DO
- СИМВОЛ = очередной символ из входного потока
- IF СТРОКА+СИМВОЛ в таблице строк THEN
- СТРОКА = СТРОКА+СИМВОЛ
- ELSE
- вывести в выходной поток код для СТРОКА
- добавить в таблицу строк СТРОКА+СИМВОЛ
- СТРОКА = СИМВОЛ
- END of IF
- END of WHILE
- вывести в выходной поток код для СТРОКА 

#### Кодирование фраз
Рассмотрим несколько вариантов кодирования фраз.
Если при кодировании выходной последовательности будет использоваться алгоритм Хаффмана или арифметическое кодирование, мы можем встретиться с раздутием данных. У алгоритма Хаффмана есть ряд недостатков: 
- Для восстановления содержимого сжатого сообщения декодер должен знать таблицу частот, которой пользовался кодер. Следовательно, длина сжатого сообщения увеличивается на длину таблицы частот, которая должна посылаться впереди данных, что может свести на нет все усилия по сжатию сообщения.
- Необходимо наличие полной частотной статистики перед началом кодирования требует двух проходов по сообщению: одного для построения модели сообщения(таблицы частот и дерева), второго для кодирования.

В арифметическом кодировании также есть ряд недостатков:
- Требуются данные о частотности использования символов, а следовательно, необходимо сформировать модель входных данных на основании количественных или статистических характеристик, что требует дополнительного прохода по данным.
- Из-за несовершенства представления чисел с плавающей точкой в памяти компьютера, некоторые дробные числа не могут быть точно представлены в двоичном коде, используемом современными процессорами, границы символов будут округлены, что может повлечь за собой неверную работу алгоритма при больших объёмах данных.

Также для решения вопроса кодирования фраз можно применить оптимальный универсальный код, например, кода Левенштейна или кода Элиаса.
 
Код Элиаса:
- Этот код удобно использовать для сжатия данных, в которых маленькие значения встречаются намного чаще, чем большие, поэтому так же необходимо сначала построить вероятностную модель и передавать ее для декодирования.

Код Левенштейна:
- Так же для лучшего распределения кодов следует сформировать модель статических и количественных характеристик, ведь уже для числа 5671 код будет состоять из 21 бита.

Можно использовать для кодирования фраз коды фиксированной длины, однако:
- Это может негативно сказаться на эффективности сжатия, так как, для начальных кодируемых символов этот подход скорее будет раздувать данные, а не сжимать, а также общий размер словаря получается не так велик.
Но такой принцип будет раздумать только маленькие данные(например, пустой файл) и большие файлы с большим количество уникальных строк, этому для больших файлов следует увеличивать размер словаря.

#### Алгоритм записи и считывания из бинарного файла
Так как запись в файл можно осуществлять только по 8 бит, будем записывать полученный индекс подстроки как итоговый двоичный n-битный код(n - фиксированное). Создадим 2 переменные: rack - будет отвечать за итоговый байт и mask - будет отвечать за перемещение по n-битному коду(т.к. можно считывать по 8 бит, установим её равной 128(будем использовать степени от 0 до 7)). Для n-битного кода также создадим переменную word_mask,  которая будет отвечать за рассматриваемую на данный момент позицию кода, следовательно переменная будет равна 2^(n - 1). Для каждой позиции кода, выполним следующий алгоритм(пока word_mask не равно 0):
- Побитово перемножаем mask и word_mask, если результат не равен нулю, значит, встретили 1 на k позиции, результат запоминаем в rack.(Осуществляется перевод в двоичную систему)
- Делим mask на 2(уменьшаем количество позиций, которые осталось просмотреть)
- Если mask равно 0, то выполняем вывод в файл rack, mask снова присваиваем 128.
- Т.к. выполнили все возможные проверки для позиции, просматриваем следующую - делим word_mask на 2. 

Аналогично происходит считывание.
Если размер конечной последовательности не кратен 8, то дописывается недостающее число нулей.

### Алгоритм распаковки
Алгоритм распаковки LZW получает выходной поток кодов от алгоритма сжатия и использует его для точного восстановления входного потока. Одной из причин эффективности LZW-алгоритма является то, что он не нуждается в хранении таблицы строк, полученной при сжатии. Таблица может быть точно восстановлена при распаковке на основе выходного потока алгоритма сжатия. Это возможно потому, что алгоритм сжатия выводит строковую и символьную компоненты кода прежде чем он поместит этот код в выходной поток. Это означает, что сжатые данные не обременены необходимостью тянуть за собой большую таблицу перевода.
В алгоритме сжатия существуют некоторые исключительные ситуации, которые создают проблемы при распаковке. Если существует строка, представляющая пару (СТРОКА СИМВОЛ) и уже определенную в таблице, а просматриваемый входной поток содержит последовательность СТРОКА СИМВОЛ СТРОКА СИМВОЛ СТРОКА, алгоритм сжатия выведет код прежде, чем распаковщик получит возможность определить его.
Процедура распаковки, обрабатывающая все возсожные ситуации LZW-распаковки:
- читать СТАРЫЙ_КОД
- вывести СТАРЫЙ_КОД
- СИМВОЛ = СТАРЫЙ_КОД
- WHILE входной поток не пуст DO
- читать НОВЫЙ_КОД
- IF NOT в таблице перевода НОВЫЙ_КОД THEN
- СТРОКА = перевести СТАРЫЙ_КОД
- СТРОКА = СТРОКА+СИМВОЛ
- ELSE
- СТРОКА = перевести НОВЫЙ_КОД
- END of IF
- вывести СТРОКУ
- СИМВОЛ = первый символ СТРОКИ
- добавить в таблицу перевода СТАРЫЙ_КОД+СИМВОЛ
- СТАРЫЙ_КОД = НОВЫЙ_КОД
- END of WHILE

## Преимущества алгоритма LZW:
- Алгоритм является однопроходным.
- Для декомпрессии не надо сохранять таблицу строк в файл для распаковки. Алгоритм построен таким образом, что мы в состоянии восстановить таблицу строк, пользуясь только потоком кодов.
- Для распаковки(декодирования) не требуется сохранение словаря.
- Алгоритм восстанавливает исходный файл без искажений в нем.

## Недостатки алгоритма LZW:
- Алгоритм не проводит анализ входных данных.

## Применение
Метод позволяет достичь одну из наилучших степеней сжатия среди других существующих методов сжатия графических данных, при полном отсутствии потерь или искажений в исходных файлах.
В настоящее время испольуется в файлах формата TIFF, PDF, GIF, PostScript и других, а также отчасти во многих популярных программах сжатия данных (ZIP, ARJ, LHA).Алгоритм стал частью стандарта на формат изображений GIF. Он также может (опционально) использоваться в формате TIFF. Помимо этого, алгоритм применяется в протоколе модемной связи v.42bis и стандарте PDF(хотя по умолчанию большая часть текстовых и визуальных данных в PDF сжимается с помощью алгоритма Deflate).

## Описания похожих алгоритмов

Сравним алгоритм с другими многоцелевыми алгоритмами:
1. LZ77
2. Кодом Хаффмана
3. Deflate

### Сравнение с LZ77
Основная идея алгоритма это замена повторного вхождения строки ссылкой на одну из предыдущих позиций вхождения. Для этого используют метод скользящего окна. Скользящее окно можно представить в виде динамической структуры данных, которая организована так, чтобы запоминать «сказанную» ранее информацию и предоставлять к ней доступ. Таким образом, сам процесс сжимающего кодирования согласно LZ77 напоминает написание программы, команды которой позволяют обращаться к элементам скользящего окна, и вместо значений сжимаемой последовательности вставлять ссылки на эти значения в скользящем окне. В стандартном алгоритме LZ77 совпадения строки кодируются парой:
~Длина совпадения (match length)
~Cмещение (offset) или дистанция (distance)
Кодируемая пара трактуется именно как команда копирования символов из скользящего окна с определенной позиции, или дословно как: «Вернуться в словаре на значение смещения символов и скопировать значение длины символов, начиная с текущей позиции». Особенность данного алгоритма сжатия заключается в том, что использование кодируемой пары длина-смещение является не только приемлемым, но и эффективным в тех случаях, когда значение длины превышает значение смещения. Пример с командой копирования не совсем очевиден: «Вернуться на 1 символ назад в буфере и скопировать 7 символов, начиная с текущей позиции». Каким образом можно скопировать 7 символов из буфера, когда в настоящий момент в буфере находится только 1 символ? Однако следующая интерпретация кодирующей пары может прояснить ситуацию: каждые 7 последующих символов совпадают (эквивалентны) с 1 символом перед ними. Это означает, что каждый символ можно однозначно определить переместившись назад в буфере, даже если данный символ еще отсутствует в буфере на момент декодирования текущей пары длина-смещение.
Известно, что LZ77 жадным образом разлагает строку x на фразы f1, f2, ...fw, так что каждая фраза fh либо является символом, либо является подстрокой строки f1, f2, ..., f(h-1).В худшем случае z может быть в O(n / log(n) ^ (0.5)) раз больше, чем w. С другой стороны, известно, что z всегда не меньше w, и даже более того, z0 всегда не меньше w. Иными словами, LZW и даже «оптимальная» версия LZW, содержащая z0 фраз, не может быть лучше LZ77(по крайней мере существенно — обратите внимание, что здесь обсуждается число фраз, а не способ их кодирования), а в некоторых патологических случаях может быть катастрофически хуже.

### Сравнение с кодом Хаффмана
Один из первых алгоритмов эффективного кодирования информации был предложен Д. А. Хаффманом в 1952 году. Идея алгоритма состоит в следующем: зная вероятности появления символов в сообщении, можно описать процедуру построения кодов переменной длины, состоящих из целого количества битов. Символам с большей вероятностью ставятся в соответствие более короткие коды. Коды Хаффмана обладают свойством префиксности (то есть ни одно кодовое слово не является префиксом другого), что позволяет однозначно их декодировать.
Классический алгоритм Хаффмана на входе получает таблицу частот встречаемости символов в сообщении. Далее на основании этой таблицы строится дерево кодирования Хаффмана (Н-дерево).
1. Символы входного алфавита образуют список свободных узлов. Каждый лист имеет вес, который может быть равен либо вероятности, либо количеству вхождений символа в сжимаемое сообщение.
2. Выбираются два свободных узла дерева с наименьшими весами.
3. Создается их родитель с весом, равным их суммарному весу.
4. Родитель добавляется в список свободных узлов, а два его потомка удаляются из этого списка.
5. Одной дуге, выходящей из родителя, ставится в соответствие бит 1, другой — бит 0. Битовые значения ветвей, исходящих от корня, не зависят от весов потомков.
6. Шаги, начиная со второго, повторяются до тех пор, пока в списке свободных узлов не останется только один свободный узел. Он и будет считаться корнем дерева.
Классический алгоритм Хаффмана имеет ряд существенных недостатков. Во-первых, для восстановления содержимого сжатого сообщения декодер должен знать таблицу частот, которой пользовался кодер. Следовательно, длина сжатого сообщения увеличивается на длину таблицы частот, которая должна посылаться впереди данных, что может свести на нет все усилия по сжатию сообщения. Кроме того, необходимость наличия полной частотной статистики перед началом собственно кодирования требует двух проходов по сообщению: одного для построения модели сообщения (таблицы частот и Н-дерева), другого для собственно кодирования. Во-вторых, избыточность кодирования обращается в ноль лишь в тех случаях, когда вероятности кодируемых символов являются обратными степенями числа 2.
В данном случае LZW практичней использовать, поскольку для декодирования не нужно хранить дерево. Так же требуется всего один проход для создания закодированной последовательности и для ее декодирования.

### Сравнение с Deflate
Deflate — это алгоритм сжатия без потерь, использующий комбинацию алгоритмов LZ77 и Хаффмана.
Deflate-поток содержит серии блоков. Перед каждым блоком находится трёхбитовый заголовок:
Один бит: флаг последнего блока.
~1: блок последний.
~0: блок не последний.
Два бита: метод, с помощью которого были закодированы данные.
~00: данные не закодированы (в блоке находятся непосредственно выходные данные).
~01: данные закодированы по методу статического Хаффмана.
~10: данные закодированы по методу динамического Хаффмана.
~11: зарезервированное значение (ошибка).
Большая часть блоков кодируется с помощью метода 10 (динамический Хаффман), который предоставляет оптимизированное дерево кодов Хаффмана для каждого нового блока. Инструкции для создания дерева кодов Хаффмана следуют непосредственно за заголовком блока.
Процесс сжатия данных с помощью Deflate состоит из двух частей:
1. Замена дублируемой информации (в пределах указанного окна) со ссылкой на предыдущую идентичную часть.
2. Применение кодировки Хаффмана для уменьшения размера наиболее часто встречающихся символов.
Благодаря этим блокам степень сжатия данных значительно повышается, а поскольку коды Хаффмана используются для повторяющихся частей, для передачи таблицы частот не требуется много памяти, поэтому он практичней LZW.

