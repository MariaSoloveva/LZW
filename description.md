# Описание программы

## Краткое описание логики
Основная функция main принимает в качестве аргументов:
Первый аргумент - пусть до входного файла
Второй аргумент - путь до выходного файла
Третий аргумент - выбор метода (сompress / decompress)

Методы для сжатия и распаковки файлов принимают на вход уже созданные и открытые файлы. Все проверки на правильность открытия осуществляются в функциях compress и decompress. Также исключения бросаются в самом начале программы, когда проверятся корректно ли введены аргументы командной строки.
Данная реализация работает с 12-битными кодами. Итоговые коды будут записаны в сжатом файле как двоичные представления символов char номера которых определяются программой. Значения кодов 0 - 255 соответствуют отдельным байтам, 256 - конец потока / файла, а коды 257 - 4095 соответствуют подстрокам. Запись всех символов 12 битами обеспечивает однозначное декодирование.
В файлах BinaryFile.hpp и BinaryFile.сpp описана структура BinaryFile, отвечающая за хранение бинарных файлов и информации, относящейся к ним. Функции считывания одного бита и нескольких бит и их записи, также реализованы в этих файлах. В этих файлах присутствует функция измерения размера файла и посчета коэффициента сжатия для сбора статистики.
В случае, если длина битового потока не кратна 8 


## Использованные структуры данных
В качестве таблицы(словаря) использовался ассоциативный контейнер std::unordered_map из стандартной библиотеки, который является хеш-таблицей. Была выбрана хеш-таблица, поскольку необходимо осуществлять быстрый доступ к элементам по ключу(а так же их вставку), а в данном контейнере это происходит в среднем за О(1) и в худшем случае, за О(n).

## Оценка сложности
Функция create_default_dictionary создает словарь за константное время.
Функция поиска существующей фразы и вставка новой будут выполняться в среднем за О(1) и в худшем случае за О(n).
Поскольку функции compress и decompress являются однопроходными - они линейно зависят от размеров файлов, их работа будет осуществляться за O(n). При каждом новом считывании символа происходит, как минимум поиск подстроки. Если же встречается строка, которой нет в таблице - происходит поиск и добавление. Если на каждой итерации будет находиться новая строка, программа будет работать за O(n^2). Получается, что в худшем случае программа будет работать за O(n^2).

## Оценка использования памяти
Дополнительная память динамически выделяется под хеш-таблицу(словарь)(может раздуваться в зависимости от размера файла), но так как введена переменная MAX_CODE(=((1 << BITS)-1)) для ограничения количества фраз в словаре максимальная возможная память, которая будет выделена под словарь асимптотически стремится O(2^BITS).

