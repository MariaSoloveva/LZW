# Описание программы

## Краткое описание логики
Основная функция main принимает в качестве аргументов:
Первый аргумент - пусть до входного файла
Второй аргумент - путь до выходного файла
Третий аргумент - выбор метода (сompress / decompress)

Методы для сжатия и распаковки файлов принимают на вход уже созданные и открытые файлы. Все проверки на правильность открытия осуществляются в функциях compress и decompress. Также исключения бросаются в самом начале программы, когда проверятся корректно ли введены аргументы командной строки и в случае, когда происходит ошибка при считывании входных данных.
Итоговые коды будут записаны в сжатом файле в файле символа char номер которого определяется программой. Сжатые символы начинаеются с номера 257 и заканчиваются 4095.
В файлах BinaryFile.hpp и BinaryFile.сpp описана структура BinaryFile, отвечающая за хранение бинарных файлов и информации, относящейся к ним. Функции считывания одного бита и нескольких бит, а также их записи, также реализованы в этих файлах. Также в этих файлах присутствует функция измерения размера файла и посчета коэффициента сжатия для сбора статистики.


## Использованные структуры данных
В качестве таблицы(словаря) использовался ассоциативный контейнер std::unordered_map из стандартной библиотеки, который является хеш-таблицей. Была выбрана хеш-таблица, поскольку необходимо осуществлять быстрый доступ к элементам по ключу(а так же их вставку), а в данном контейнере это происходит в среднем за О(1) и в худшем случае, за О(n).

## Оценка сложности
Функция create_default_dictionary создает словарь за константное время.
Функция поиска существующей фразы и вставка новой будут выполняться в среднем за О(1) и в худшем случае за О(n).
Поскольку функции compress и decompress являются однопроходными - они линейно зависят от размеров файлов, их работа будет осуществляться за O(n). При каждом новом считывании символа происходит, как минимум поиск подстроки. Если же встречается строка, которой нет в таблице - происходит поиск и добавление. Если на каждой итерации будет находиться новая строка, программа будет работать за O(n^2). Получается, что в худшем случае программа будет работать за O(n^2).

## Оценка использования памяти
Дополнительная память динамически выделяется под хеш-таблицу(словарь), но так как введена переменная MAX_CODE(=((1 << BITS)-1)) для ограничения количества фраз в словаре, иначе он может раздуваться в зависимости от размера файла, поэтому максимальная возможная память, которая будет выделена под словарь равна O((1 << BITS)-1)).
